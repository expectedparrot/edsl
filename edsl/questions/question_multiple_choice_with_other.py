from __future__ import annotations
from typing import Union, Literal, Optional, List, Any

from jinja2 import Template
from pydantic import BaseModel, Field

from .question_base import QuestionBase
from .descriptors import QuestionOptionsDescriptor, OtherOptionTextDescriptor
from .decorators import inject_exception
from .question_multiple_choice import (
    MultipleChoiceResponseValidator,
)


# Create a custom response model for MultipleChoiceWithOther
class BaseMultipleChoiceWithOtherResponse(BaseModel):
    """
    Base model for multiple choice with other responses.

    Attributes:
        answer: The selected choice (can be a full string like "Other: X")
        comment: Optional comment field
        generated_tokens: Optional raw tokens generated by the model
    """

    answer: Any = Field(..., description="Selected choice")
    comment: Optional[str] = Field(None, description="Optional comment field")
    generated_tokens: Optional[Any] = Field(None, description="Generated tokens")


def create_response_model_with_other(choices: List[str], permissive: bool = False):
    """
    Create a ChoiceWithOtherResponse model class with a predefined list of choices.

    :param choices: A list of allowed values for the answer field.
    :param permissive: If True, any value will be accepted as an answer.
    :return: A new Pydantic model class.
    """
    choice_tuple = tuple(choices)

    if not permissive:

        class ChoiceWithOtherResponse(BaseMultipleChoiceWithOtherResponse):
            """
            A model for multiple choice with other responses with strict validation.
            """

            answer: Literal[choice_tuple] = Field(description="Selected choice")

            model_config = {
                "json_schema_extra": {"properties": {"answer": {"enum": choices}}}
            }

    else:

        class ChoiceWithOtherResponse(BaseMultipleChoiceWithOtherResponse):
            """
            A model for multiple choice with other responses with permissive validation.
            """

            answer: Any = Field(
                description=f"Selected choice (can be any value). Suggested choices are: {choices}"
            )

            model_config = {"title": "PermissiveChoiceWithOtherResponse"}

    return ChoiceWithOtherResponse


class MultipleChoiceWithOtherResponseValidator(MultipleChoiceResponseValidator):
    """
    Validator for multiple choice with "other" responses.

    This validator extends the MultipleChoiceResponseValidator to handle
    the case where a user selects "Other" and provides a custom response.

    Examples:
        >>> from edsl.questions import QuestionMultipleChoiceWithOther
        >>> q = QuestionMultipleChoiceWithOther(
        ...     question_name="feeling",
        ...     question_text="How are you feeling?",
        ...     question_options=["Good", "Bad", "Neutral"],
        ...     other_option_text="Other"
        ... )
        >>> validator = q.response_validator
        >>> result = validator.validate({"answer": "Good"})
        >>> sorted(result.keys())
        ['answer', 'comment', 'generated_tokens']
        >>> result["answer"]
        'Good'
        >>> # Direct "Other: X" format - full string is kept
        >>> result = validator.validate({"answer": "Other: Paris"})
        >>> result["answer"]
        'Other: Paris'
    """

    required_params = ["question_options", "use_code", "other_option_text"]

    def __init__(self, **kwargs):
        """
        Initialize the validator.

        Ensures that other_option_text is added to the question_options.
        """
        super().__init__(**kwargs)

        # Make sure other_option_text is always in the list of valid options
        question_options = list(self.question_options)
        if self.other_option_text not in question_options:
            question_options.append(self.other_option_text)
        # Also add "Other" for backward compatibility
        if "Other" not in question_options:
            question_options.append("Other")
        self.question_options = question_options

    def validate(self, response_dict, verbose=False):
        """
        Validate the response according to the schema.

        This overrides the parent validate method to handle the "Other" option specially.
        If the answer is in the format "{other_option_text}: X", it keeps the full string
        as the answer.

        Parameters:
            response_dict: The response to validate
            verbose: Whether to print debug information

        Returns:
            A validated response dict with the full answer string preserved
        """
        # Create a copy to avoid modifying the original that may be needed elsewhere
        response_dict = response_dict.copy()
        answer = str(response_dict.get("answer", ""))

        # Check for "{other_option_text}: X" format directly in the answer field
        # If it matches, keep the full answer string as-is and accept it even if not in options
        matches_pattern = False
        answer_lower = answer.lower()
        other_option_text_lower = self.other_option_text.lower()

        # Check if answer starts with other_option_text (case-insensitive)
        if answer_lower.startswith(other_option_text_lower):
            # Remove other_option_text from the start
            remaining = answer[len(self.other_option_text) :]
            # Check if what remains starts with ": " or ":"
            if remaining.strip().startswith(":"):
                matches_pattern = True
                if verbose:
                    print(f"Detected '{self.other_option_text}: X' format: {answer}")
                    print(f"Keeping full answer as-is: {answer}")

                # Keep the full answer string (don't split it)
                response_dict["answer"] = answer

        # Try to validate with the parent validator
        try:
            validated_response = super().validate(response_dict, verbose)
            return validated_response
        except Exception as e:
            # If validation fails but the answer matches our pattern, accept it anyway
            if matches_pattern:
                if verbose:
                    print(
                        f"Validation failed but answer matches pattern, accepting: {answer}"
                    )
                # Manually construct a valid response
                validated_response = {
                    "answer": answer,
                    "comment": response_dict.get("comment"),
                    "generated_tokens": response_dict.get("generated_tokens"),
                }
                return validated_response
            # Otherwise, re-raise the exception
            raise

    def fix(self, response, verbose=False):
        """
        Attempt to fix an invalid multiple choice with other response.

        Extends the MultipleChoiceResponseValidator fix method to also
        handle "{other_option_text}: X" format responses by keeping the full string.

        Parameters:
            response: The invalid response to fix
            verbose: Whether to print debug information

        Returns:
            A fixed response dict if possible, otherwise the original response
        """
        # Check if this is an "Other" response with additional text
        response_text = str(response.get("answer", ""))

        # Handle "{other_option_text}: X" format - keep the full string
        response_text_lower = response_text.lower()
        other_option_text_lower = self.other_option_text.lower()

        # Check if answer starts with other_option_text (case-insensitive)
        if response_text_lower.startswith(other_option_text_lower):
            # Remove other_option_text from the start
            remaining = response_text[len(self.other_option_text) :]
            # Check if what remains starts with ": " or ":"
            if remaining.strip().startswith(":"):
                if verbose:
                    print(
                        f"Identified as '{self.other_option_text}: X' format: {response_text}"
                    )

                # Keep the full answer string (don't split it)
                proposed_data = {
                    "answer": response_text,
                    "comment": response.get("comment"),
                    "generated_tokens": response.get("generated_tokens"),
                }

                try:
                    # Validate the fixed answer
                    self.response_model.model_validate(proposed_data)
                    if verbose:
                        print(f"Fixed answer: {response_text}")
                    return proposed_data
                except Exception as e:
                    if verbose:
                        print(
                            f"Validation failed for '{self.other_option_text}: X' format: {e}"
                        )
                    # Even if validation fails, return the full string if it matches the pattern
                    # This matches the behavior of the validate method which accepts "Other: X" format
                    if verbose:
                        print(
                            f"Accepting '{self.other_option_text}: X' format despite validation failure: {response_text}"
                        )
                    return proposed_data

        # If not an "Other" response, try the parent class fix method
        return super().fix(response, verbose)

    valid_examples = [
        (
            {"answer": "Good"},
            {
                "question_options": ["Good", "Great", "OK", "Bad"],
                "other_option_text": "Other",
            },
        ),
        (
            {"answer": "Other: Fantastic"},
            {
                "question_options": ["Good", "Great", "OK", "Bad"],
                "other_option_text": "Other",
            },
        ),
    ]

    invalid_examples = [
        (
            {"answer": "Terrible"},
            {
                "question_options": ["Good", "Great", "OK", "Bad"],
                "other_option_text": "Other",
            },
            "Value error, Permitted values are 'Good', 'Great', 'OK', 'Bad', 'Other'",
        ),
    ]


class QuestionMultipleChoiceWithOther(QuestionBase):
    """
    A question that prompts the agent to select one option from a list of choices or specify "Other".

    QuestionMultipleChoiceWithOther extends QuestionMultipleChoice to include an "Other" option
    that allows the agent to provide a custom response when none of the predefined options
    are suitable. This is especially useful for surveys and open-ended questions where
    you want to capture responses that don't fit into predefined categories.

    Key Features:
    - All features of QuestionMultipleChoice
    - Additional "Other" option that allows custom responses
    - Customizable text for the "Other" option
    - Supports "Other: X" format where the full string is stored as the answer

    Technical Details:
    - Uses extended Pydantic models for validation
    - Preserves all functionality of QuestionMultipleChoice
    - Full answer string (e.g., "Other: X") is stored in the answer field
    - Validator handles "Other: X" format by keeping the full string

    Examples:
        Basic usage:

        ```python
        q = QuestionMultipleChoiceWithOther(
            question_name="preference",
            question_text="Which color do you prefer?",
            question_options=["Red", "Green", "Blue", "Yellow"]
        )
        ```

        Custom "Other" option text:

        ```python
        q = QuestionMultipleChoiceWithOther(
            question_name="preference",
            question_text="Which color do you prefer?",
            question_options=["Red", "Green", "Blue", "Yellow"],
            other_option_text="Something else (please specify)"
        )
        ```

        Handling "Other: X" format:

        ```python
        # If the model responds with "Other: Paris"
        q = QuestionMultipleChoiceWithOther(
            question_name="capital",
            question_text="What is the capital of France?",
            question_options=["London", "Berlin", "Madrid"]
        )
        result = q.by(model).run()
        # result will have:
        # answer.capital = "Other: Paris" (full string is stored)
        ```
    """

    question_type = "multiple_choice_with_other"
    purpose = "When options are known but you want to allow for custom responses"
    question_options: Union[list[str], list[list], list[float], list[int]] = (
        QuestionOptionsDescriptor()
    )
    other_option_text: str = OtherOptionTextDescriptor()
    _response_model = None
    response_validator_class = MultipleChoiceWithOtherResponseValidator

    def post_process_result(self, result):
        """
        Post-process the result to handle "Other: X" format.

        This method is called after the result is generated by the model
        and before it's returned to the user. It checks if the answer
        has the "Other: X" format and stores the full answer.

        Parameters:
            result: The result object to process

        Returns:
            The processed result object
        """
        # Process each result in the results list
        for r in result:
            if "answer" in r:
                question_name = self.question_name
                answer = r["answer"].get(question_name)

                # Check if the answer has the "Other: X" format or custom "Something else: X" format
                if isinstance(answer, str) and ":" in answer:
                    # Split into two parts
                    parts = answer.split(":", 1)
                    if len(parts) == 2:
                        # Check if the first part is either "Other" or matches other_option_text
                        prefix = parts[0].strip()
                        if prefix == "Other" or prefix == self.other_option_text:
                            # Extract the custom text
                            other_text = parts[1].strip()

                            # Set the answer to just "Other" (not the full "Other: X" format)
                            r["answer"][question_name] = "Other"

                            # Store the other_text in the result object as well as an attribute
                            other_text_key = f"{question_name}_other_text"
                            if "other_text" not in r:
                                r["other_text"] = {}
                            r["other_text"][other_text_key] = other_text

                            # Store the other_text as an attribute of the question instance
                            self._other_text = other_text

        return result

    def convert_to_regular_multiple_choice(self):
        """
        Convert the question to a regular multiple choice question.
        """
        from .question_multiple_choice import QuestionMultipleChoice

        return QuestionMultipleChoice(
            question_name=self.question_name,
            question_text=self.question_text,
            question_options=self.question_options,
        )

    @property
    def other_text(self):
        """
        Get the text entered for the 'Other' option.

        Returns:
            The text entered for the 'Other' option, or None if not applicable
        """
        return getattr(self, "_other_text", None)

    def __init__(
        self,
        question_name: str,
        question_text: str,
        question_options: Union[list[str], list[list], list[float], list[int]],
        include_comment: bool = True,
        use_code: bool = False,
        answering_instructions: Optional[str] = None,
        question_presentation: Optional[str] = None,
        permissive: bool = False,
        other_option_text: str = "Other",
    ):
        """
        Initialize a new multiple choice with "Other" question.

        Parameters
        ----------
        question_name : str
            The name of the question, used as an identifier. Must be a valid Python variable name.

        question_text : str
            The actual text of the question to be asked.

        question_options : Union[list[str], list[list], list[float], list[int]]
            The list of options the agent can select from. The "Other" option will be
            automatically added to this list.

        include_comment : bool, default=True
            Whether to include a comment field in the response.

        use_code : bool, default=False
            If True, the answer will be the index of the selected option (0-based) instead of
            the option text itself.

        answering_instructions : Optional[str], default=None
            Custom instructions for how the model should answer the question.

        question_presentation : Optional[str], default=None
            Custom template for how the question is presented to the model.

        permissive : bool, default=False
            If True, the validator will accept answers that are not in the provided options list.

        other_option_text : str, default="Other"
            The text to use for the "Other" option. This will be added to the list of options.

        Examples
        --------
        >>> q = QuestionMultipleChoiceWithOther(
        ...     question_name="color_preference",
        ...     question_text="What is your favorite color?",
        ...     question_options=["Red", "Blue", "Green", "Yellow"],
        ...     other_option_text="Something else (please specify)"
        ... )
        """
        # Initialize base attributes from QuestionBase
        self.question_name = question_name
        self.question_text = question_text
        self.question_options = question_options
        self.other_option_text = other_option_text

        # Add other specific attributes
        self._include_comment = include_comment
        self.use_code = use_code
        self.answering_instructions = answering_instructions
        self.question_presentation = question_presentation
        self.permissive = permissive

    def create_response_model(self, replacement_dict: dict = None):
        """Create a response model that allows for the 'Other' option."""
        if replacement_dict is None:
            replacement_dict = {}

        # Create options list with other_option_text and "Other" options added
        options = list(self.question_options)
        if self.other_option_text not in options:
            options.append(self.other_option_text)
        # Also add "Other" for backward compatibility
        if "Other" not in options:
            options.append("Other")

        if self.use_code:
            return create_response_model_with_other(
                list(range(len(options))), self.permissive
            )
        else:
            return create_response_model_with_other(options, self.permissive)

    @property
    def question_html_content(self) -> str:
        """Return the HTML version of the question with the Other option."""
        if hasattr(self, "option_labels"):
            option_labels = self.option_labels
        else:
            option_labels = {}

        question_html_content = Template(
            """
        {% for option in question_options %} 
        <div>
        <input type="radio" id="{{ option }}" name="{{ question_name }}" value="{{ option }}">
        <label for="{{ option }}">
        {{ option }}
        {% if option in option_labels %}
        : {{ option_labels[option] }}
        {% endif %}
        </label>
        </div>
        {% endfor %}
        
        <div>
        <input type="radio" id="{{ other_option }}" name="{{ question_name }}" value="{{ other_option }}">
        <label for="{{ other_option }}">{{ other_option }}</label>
        <input type="text" id="{{ question_name }}_other_text" name="{{ question_name }}_other_text" 
               placeholder="Please specify" style="display:none;">
        </div>
        
        <script>
        document.getElementById('{{ other_option }}').addEventListener('change', function() {
            document.getElementById('{{ question_name }}_other_text').style.display = 'inline-block';
        });
        
        // Hide the text input when any other option is selected
        {% for option in question_options %}
        document.getElementById('{{ option }}').addEventListener('change', function() {
            document.getElementById('{{ question_name }}_other_text').style.display = 'none';
        });
        {% endfor %}
        </script>
        """
        ).render(
            question_name=self.question_name,
            question_options=self.question_options,
            option_labels=option_labels,
            other_option=self.other_option_text,
        )
        return question_html_content

    def by(self, *models, **kwargs):
        """
        Chain this question with one or more models.

        Parameters:
            *models: One or more models to chain with this question
            **kwargs: Additional kwargs to pass to the parent class

        Returns:
            The chained object
        """
        return super().by(*models, **kwargs)

    @classmethod
    @inject_exception
    def example(
        cls, include_comment=False, use_code=False
    ) -> QuestionMultipleChoiceWithOther:
        """Return an example instance."""
        return cls(
            question_text="How are you?",
            question_options=["Good", "Great", "OK", "Bad"],
            question_name="how_feeling_with_other",
            include_comment=include_comment,
            use_code=use_code,
            other_option_text="Other (please specify)",
        )


if __name__ == "__main__":
    import doctest

    doctest.testmod(optionflags=doctest.ELLIPSIS)
