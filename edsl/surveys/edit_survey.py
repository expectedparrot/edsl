import math

from typing import Union, Optional, TYPE_CHECKING

if TYPE_CHECKING:
    from ..questions import QuestionBase
    from .survey import Survey
    from ..instructions import Instruction, ChangeInstruction

from .exceptions import SurveyError, SurveyCreationError
from .rules.rule import Rule
from .base import RulePriority, EndOfSurvey


class EditSurvey:
    def __init__(self, survey):
        self.survey = survey

    def move_question(self, identifier: Union[str, int], new_index: int) -> "Survey":
        if isinstance(identifier, str):
            if identifier not in self.survey.question_names:
                raise SurveyError(
                    f"Question name '{identifier}' does not exist in the survey."
                )
            index = self.survey.question_name_to_index[identifier]
        elif isinstance(identifier, int):
            if identifier < 0 or identifier >= len(self.survey.questions):
                raise SurveyError(f"Index {identifier} is out of range.")
            index = identifier
        else:
            raise SurveyError(
                "Identifier must be either a string (question name) or an integer (question index)."
            )

        moving_question = self.survey._questions[index]

        new_survey = self.survey.delete_question(index)
        new_survey.add_question(moving_question, new_index)
        return new_survey

    def add_question(
        self, question: "QuestionBase", index: Optional[int] = None
    ) -> "Survey":
        import time

        # Track timing for this method
        if not hasattr(EditSurvey, "_add_question_timing"):
            EditSurvey._add_question_timing = {
                "name_check": 0.0,
                "index_validation": 0.0,
                "list_insert": 0.0,
                "pseudo_indices_update": 0.0,
                "rule_iteration": 0.0,
                "add_new_rule": 0.0,
                "memory_plan_update": 0.0,
                "total": 0.0,
                "call_count": 0,
                "interior_insertion_count": 0,
            }

        start = time.time()

        t1 = time.time()
        if question.question_name in self.survey.question_names:
            raise SurveyCreationError(
                f"""Question name '{question.question_name}' already exists in survey. Existing names are {self.survey.question_names}."""
            )
        EditSurvey._add_question_timing["name_check"] += time.time() - t1

        t2 = time.time()
        if index is None:
            index = len(self.survey.questions)

        if index > len(self.survey.questions):
            raise SurveyCreationError(
                f"Index {index} is greater than the number of questions in the survey."
            )
        if index < 0:
            raise SurveyCreationError(f"Index {index} is less than 0.")

        interior_insertion = index != len(self.survey.questions)
        EditSurvey._add_question_timing["index_validation"] += time.time() - t2

        # index = len(self.survey.questions)
        # TODO: This is a bit ugly because the user
        # doesn't "know" about _questions - it's generated by the
        # descriptor.
        t3 = time.time()
        self.survey._questions.insert(index, question)
        EditSurvey._add_question_timing["list_insert"] += time.time() - t3

        t4 = time.time()
        if interior_insertion:
            for question_name, old_index in self.survey._pseudo_indices.items():
                if old_index >= index:
                    self.survey._pseudo_indices[question_name] = old_index + 1

        self.survey._pseudo_indices[question.question_name] = index
        EditSurvey._add_question_timing["pseudo_indices_update"] += time.time() - t4

        ## Re-do question_name to index - this is done automatically
        # for question_name, old_index in self.survey.question_name_to_index.items():
        #     if old_index >= index:
        #         self.survey.question_name_to_index[question_name] = old_index + 1

        ## Need to re-do the rule collection and the indices of the questions

        ## If a rule is before the insertion index and next_q is also before the insertion index, no change needed.
        ## If the rule is before the insertion index but next_q is after the insertion index, increment the next_q by 1
        ## If the rule is after the insertion index, increment the current_q by 1 and the next_q by 1

        # using index + 1 presumes there is a next question
        t5 = time.time()
        if interior_insertion:
            EditSurvey._add_question_timing["interior_insertion_count"] += 1
            for rule in self.survey.rule_collection:
                if rule.current_q >= index:
                    rule.current_q += 1
                if rule.next_q >= index:
                    rule.next_q += 1
        EditSurvey._add_question_timing["rule_iteration"] += time.time() - t5

        # add a new rule
        t6 = time.time()
        self.survey.rule_collection.add_rule(
            Rule(
                current_q=index,
                expression="True",
                next_q=index + 1,
                question_name_to_index=self.survey.question_name_to_index,
                priority=RulePriority.DEFAULT.value,
            )
        )
        EditSurvey._add_question_timing["add_new_rule"] += time.time() - t6

        # a question might be added before the memory plan is created
        # it's ok because the memory plan will be updated when it is created
        t7 = time.time()
        if hasattr(self.survey, "memory_plan"):
            self.survey.memory_plan.add_question(question)
        EditSurvey._add_question_timing["memory_plan_update"] += time.time() - t7

        EditSurvey._add_question_timing["total"] += time.time() - start
        EditSurvey._add_question_timing["call_count"] += 1

        # Print stats every 5000 calls
        if EditSurvey._add_question_timing["call_count"] % 5000 == 0:
            stats = EditSurvey._add_question_timing
            print(f"\n{'='*70}")
            print(f"[EDIT_SURVEY.ADD_QUESTION] Call #{stats['call_count']}")
            print(f"{'='*70}")
            print(f"Total time:              {stats['total']:.3f}s")
            print(f"Interior insertions:     {stats['interior_insertion_count']}")
            print(f"")
            print(f"Component breakdown:")
            print(
                f"  rule_iteration        {stats['rule_iteration']:.3f}s ({100*stats['rule_iteration']/stats['total']:.1f}%)"
            )
            print(
                f"  add_new_rule          {stats['add_new_rule']:.3f}s ({100*stats['add_new_rule']/stats['total']:.1f}%)"
            )
            print(
                f"  name_check            {stats['name_check']:.3f}s ({100*stats['name_check']/stats['total']:.1f}%)"
            )
            print(
                f"  pseudo_indices_update {stats['pseudo_indices_update']:.3f}s ({100*stats['pseudo_indices_update']/stats['total']:.1f}%)"
            )
            print(
                f"  memory_plan_update    {stats['memory_plan_update']:.3f}s ({100*stats['memory_plan_update']/stats['total']:.1f}%)"
            )
            print(
                f"  list_insert           {stats['list_insert']:.3f}s ({100*stats['list_insert']/stats['total']:.1f}%)"
            )
            print(
                f"  index_validation      {stats['index_validation']:.3f}s ({100*stats['index_validation']/stats['total']:.1f}%)"
            )
            print(f"")
            print(f"Avg per call:            {stats['total']/stats['call_count']:.6f}s")
            print(f"{'='*70}\n")

        return self.survey

    def delete_question(self, identifier: Union[str, int]) -> "Survey":
        """
        Delete a question from the survey.

        :param identifier: The name or index of the question to delete.
        :return: The updated Survey object.

        >>> from edsl import QuestionMultipleChoice, Survey
        >>> q1 = QuestionMultipleChoice(question_text="Q1", question_options=["A", "B"], question_name="q1")
        >>> q2 = QuestionMultipleChoice(question_text="Q2", question_options=["C", "D"], question_name="q2")
        >>> s = Survey().add_question(q1).add_question(q2)
        >>> _ = s.delete_question("q1")
        >>> len(s.questions)
        1
        >>> _ = s.delete_question(0)
        >>> len(s.questions)
        0
        """
        if isinstance(identifier, str):
            if identifier not in self.survey.question_names:
                raise SurveyError(
                    f"Question name '{identifier}' does not exist in the survey."
                )
            index = self.survey.question_name_to_index[identifier]
        elif isinstance(identifier, int):
            if identifier < 0 or identifier >= len(self.survey.questions):
                raise SurveyError(f"Index {identifier} is out of range.")
            index = identifier
        else:
            raise SurveyError(
                "Identifier must be either a string (question name) or an integer (question index)."
            )

        # Remove the question
        deleted_question = self.survey._questions.pop(index)
        del self.survey._pseudo_indices[deleted_question.question_name]

        # Update indices
        for question_name, old_index in self.survey._pseudo_indices.items():
            if old_index > index:
                self.survey._pseudo_indices[question_name] = old_index - 1

        # Update rules
        from .rules import RuleCollection

        new_rule_collection = RuleCollection()
        for rule in self.survey.rule_collection:
            if rule.current_q == index:
                continue  # Remove rules associated with the deleted question
            if rule.current_q > index:
                rule.current_q -= 1
            if rule.next_q > index:
                rule.next_q -= 1

            if rule.next_q == index:
                if index == len(self.survey.questions):
                    rule.next_q = EndOfSurvey
                else:
                    rule.next_q = index

            new_rule_collection.add_rule(rule)
        self.survey.rule_collection = new_rule_collection

        # Update memory plan if it exists
        if hasattr(self.survey, "memory_plan"):
            self.survey.memory_plan.remove_question(deleted_question.question_name)

        return self.survey

    def add_instruction(
        self, instruction: Union["Instruction", "ChangeInstruction"]
    ) -> "Survey":
        """
        Add an instruction to the survey.

        :param instruction: The instruction to add to the survey.

        >>> from edsl import Instruction
        >>> from edsl.surveys import Survey
        >>> i = Instruction(text="Pay attention to the following questions.", name="intro")
        >>> s = Survey().add_instruction(i)
        >>> s._instruction_names_to_instructions
        {'intro': Instruction(name="intro", text="Pay attention to the following questions.")}
        >>> s._pseudo_indices
        {'intro': -0.5}
        """

        if instruction.name in self.survey._instruction_names_to_instructions:
            raise SurveyCreationError(
                f"""Instruction name '{instruction.name}' already exists in survey. Existing names are {self.survey._instruction_names_to_instructions.keys()}."""
            )
        self.survey._instruction_names_to_instructions[instruction.name] = instruction

        # was the last thing added an instruction or a question?
        if self.survey._pseudo_indices.last_item_was_instruction:
            pseudo_index = (
                self.survey._pseudo_indices.max_pseudo_index
                + (
                    math.ceil(self.survey._pseudo_indices.max_pseudo_index)
                    - self.survey._pseudo_indices.max_pseudo_index
                )
                / 2
            )
        else:
            pseudo_index = self.survey._pseudo_indices.max_pseudo_index + 1.0 / 2.0
        self.survey._pseudo_indices[instruction.name] = pseudo_index

        return self.survey


if __name__ == "__main__":
    import doctest

    doctest.testmod()
