/**
 * Parity tests for TypeScript Store implementation.
 *
 * These tests verify that the TypeScript implementation produces
 * identical results to the Python implementation by using fixtures
 * generated by the Python code.
 *
 * Run with: deno run --allow-read tests/parity.test.ts
 */

import { applyEvent } from "../applyEvent.ts";
import { createEvent } from "../eventUtils.ts";
import { storeFromDict } from "../store.ts";

interface Fixture {
  name: string;
  description: string;
  initial_store: { entries: Record<string, unknown>[]; meta: Record<string, unknown> };
  event: { name: string; payload: Record<string, unknown> };
  expected_store: { entries: Record<string, unknown>[]; meta: Record<string, unknown> };
}

async function loadFixtures(): Promise<Fixture[]> {
  const fixturesPath = new URL("./fixtures.json", import.meta.url);
  const data = await Deno.readTextFile(fixturesPath);
  return JSON.parse(data);
}

function deepEqual(a: unknown, b: unknown): boolean {
  if (a === b) return true;
  if (a === null || b === null) return a === b;
  if (typeof a !== typeof b) return false;

  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) return false;
    return a.every((val, i) => deepEqual(val, b[i]));
  }

  if (typeof a === "object" && typeof b === "object") {
    const aObj = a as Record<string, unknown>;
    const bObj = b as Record<string, unknown>;
    const aKeys = Object.keys(aObj).sort();
    const bKeys = Object.keys(bObj).sort();
    if (!deepEqual(aKeys, bKeys)) return false;
    return aKeys.every((key) => deepEqual(aObj[key], bObj[key]));
  }

  return false;
}

function formatDiff(expected: unknown, actual: unknown, path: string = ""): string {
  if (deepEqual(expected, actual)) return "";

  const lines: string[] = [];

  if (Array.isArray(expected) && Array.isArray(actual)) {
    if (expected.length !== actual.length) {
      lines.push(`${path}: array length mismatch (expected ${expected.length}, got ${actual.length})`);
    }
    const maxLen = Math.max(expected.length, actual.length);
    for (let i = 0; i < maxLen; i++) {
      const diff = formatDiff(expected[i], actual[i], `${path}[${i}]`);
      if (diff) lines.push(diff);
    }
  } else if (
    typeof expected === "object" &&
    expected !== null &&
    typeof actual === "object" &&
    actual !== null
  ) {
    const expObj = expected as Record<string, unknown>;
    const actObj = actual as Record<string, unknown>;
    const allKeys = new Set([...Object.keys(expObj), ...Object.keys(actObj)]);
    for (const key of allKeys) {
      const diff = formatDiff(expObj[key], actObj[key], path ? `${path}.${key}` : key);
      if (diff) lines.push(diff);
    }
  } else {
    lines.push(`${path}: expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);
  }

  return lines.join("\n");
}

function runTest(fixture: Fixture): { passed: boolean; error?: string } {
  try {
    // Create initial store from fixture
    const store = storeFromDict(fixture.initial_store as Record<string, unknown>);

    // Create event from fixture
    const event = createEvent(fixture.event.name, fixture.event.payload);

    // Apply event
    applyEvent(event, store);

    // Compare result to expected
    const expected = fixture.expected_store;
    const actual = { entries: store.entries, meta: store.meta };

    if (deepEqual(expected, actual)) {
      return { passed: true };
    } else {
      const diff = formatDiff(expected, actual);
      return { passed: false, error: `Result mismatch:\n${diff}` };
    }
  } catch (e) {
    return { passed: false, error: `Exception: ${e}` };
  }
}

async function main() {
  const fixtures = await loadFixtures();
  let passed = 0;
  let failed = 0;
  const failures: { name: string; error: string }[] = [];

  console.log(`Running ${fixtures.length} parity tests...\n`);

  for (const fixture of fixtures) {
    const result = runTest(fixture);
    if (result.passed) {
      passed++;
      console.log(`✓ ${fixture.name}`);
    } else {
      failed++;
      console.log(`✗ ${fixture.name}`);
      failures.push({ name: fixture.name, error: result.error! });
    }
  }

  console.log(`\n${"=".repeat(60)}`);
  console.log(`Results: ${passed} passed, ${failed} failed`);

  if (failures.length > 0) {
    console.log(`\n${"=".repeat(60)}`);
    console.log("FAILURES:\n");
    for (const { name, error } of failures) {
      console.log(`--- ${name} ---`);
      console.log(error);
      console.log();
    }
    Deno.exit(1);
  } else {
    console.log("\nAll tests passed! TypeScript implementation matches Python.");
    Deno.exit(0);
  }
}

main();
